using MyHorizons.Data;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

public static class DesignPatternExtension
{
	public static UnityEngine.Color[] GetPixels(this DesignPattern pattern)
	{
		int width = 32;
		int height = 32;
		UnityEngine.Color[] pixels = new UnityEngine.Color[width * height];
		for (int y = 0; y < height; y++)
		{
			for (int x = 0; x < width; x++)
			{
				int colorIndex = pattern.GetPixel(x, y);
				if (colorIndex < 0x0F)
				{
					var color = pattern.Palette[colorIndex];
					pixels[x + y * width] = new UnityEngine.Color(((float) color.R) / 255f, ((float) color.G) / 255f, ((float) color.B) / 255f);
				}
				else
				{
					pixels[x + y * width] = new UnityEngine.Color(0f, 0f, 0f, 0f);
				}
			}
		}
		return pixels;
	}

	public static Sprite GetPreview(this DesignPattern pattern)
	{
		int width = 32;
		int height = 32;
		var texture = new Texture2D(width, height, TextureFormat.RGBA32, false, true);
		texture.filterMode = FilterMode.Point;
		UnityEngine.Color[] pixels = pattern.GetPixels();
		UnityEngine.Color[] resultPixels = new UnityEngine.Color[pixels.Length];
		for (int y = 0; y < height; y++)
			for (int x = 0; x < width; x++)
				resultPixels[x + (height - 1 - y) * width] = pixels[x + y * width];

		texture.SetPixels(resultPixels);
		texture.Apply();
		return UnityEngine.Sprite.Create(texture, new Rect(0, 0, 32, 32), new Vector2(0.5f, 0.5f));
	}

	public static void FromBitmap(this DesignPattern pattern, Bitmap bitmap)
	{
		Dictionary<System.Drawing.Color, byte> colorMap = new Dictionary<System.Drawing.Color, byte>();
		for (int i = 0; i < 15; i++)
		{
			pattern.Palette[i].R = 0;
			pattern.Palette[i].G = 0;
			pattern.Palette[i].B = 0;
		}

		int width = 32;
		int height = 32;
		for (var y = 0; y < width; y++)
		{
			for (var x = 0; x < height; x++)
			{
				var pixelColor = System.Drawing.Color.FromArgb(0, 0, 0, 0);
				if (x < bitmap.Width && y < bitmap.Height)
					pixelColor = bitmap.GetPixel(x, y);

				byte index = 0xF;
				if (colorMap.ContainsKey(pixelColor))
					index = colorMap[pixelColor];
				else
				{
					index = (byte) colorMap.Count;
					pattern.Palette[index].R = pixelColor.R;
					pattern.Palette[index].G = pixelColor.G;
					pattern.Palette[index].B = pixelColor.B;
					colorMap.Add(pixelColor, index);
				}

				pattern.SetPixel(x, y, index);
			}
		}
	}

	private static (byte, byte, byte)[] EmptyPalette = new (byte, byte, byte)[]
	{
		( 229, 45,  45  ),
		( 229, 119, 45  ),
		( 229, 229, 30  ),
		( 119, 229, 45  ),
		( 27,  139, 27  ),
		( 57,  183, 214 ),
		( 42,  145, 214 ),
		( 61,  61,  229 ),
		( 137, 76,  229 ),
		( 229, 91,  201 ),
		( 229, 168, 152 ),
		( 139, 80,  65  ),
		( 229, 229, 229 ),
		( 110, 110, 110 ),
		( 20,  20,  20  )
	};
	private static byte[] EmptyPixels = new byte[] { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCA, 0xAA, 0xAC, 0xCA, 0xAA, 0xAC, 0xCA, 0xAA, 0xAC, 0xCA, 0xAA, 0xAC, 0xCA, 0xAA, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xAC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC };

	public static void Empty(this DesignPattern pattern)
	{
		for (var i = 0; i < pattern.Palette.Length; i++)
		{
			pattern.Palette[i].R = EmptyPalette[i].Item1;
			pattern.Palette[i].G = EmptyPalette[i].Item2;
			pattern.Palette[i].B = EmptyPalette[i].Item3;
		}
		Array.Copy(EmptyPixels, 0, pattern.Pixels, 0, pattern.Pixels.Length);
	}

	public static void CopyFrom(this DesignPattern pattern, DesignPattern other)
	{
		for (int i = 0; i < pattern.Palette.Length; i++)
		{
			pattern.Palette[i].R = other.Palette[i].R;
			pattern.Palette[i].G = other.Palette[i].G;
			pattern.Palette[i].B = other.Palette[i].B;
		}
		Array.Copy(other.Pixels, 0, pattern.Pixels, 0, other.Pixels.Length);
		pattern.Name = other.Name;
		pattern.PersonalID = other.PersonalID;
	}
}
